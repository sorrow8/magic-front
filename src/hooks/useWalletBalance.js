import { useState, useEffect, useCallback } from 'react'
import { useLaserEyes } from '@omnisat/lasereyes-react'

export function useWalletBalance() {
  const { address, paymentAddress, connected, network } = useLaserEyes()
  const [balance, setBalance] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  // –õ–æ–≥–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∞–¥—Ä–µ—Å–∞ —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –∫–æ—à–µ–ª–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
  useEffect(() => {
    if (connected && network && (address || paymentAddress)) {
      console.log('üîç DEBUG - LaserEyes addresses:', {
        address, // taproot –∞–¥—Ä–µ—Å
        paymentAddress, // native segwit –∞–¥—Ä–µ—Å
        connected,
        network
      });
      console.log('üåê Current network:', network);
    }
  }, [address, paymentAddress, connected, network]);

  const fetchBalance = useCallback(async () => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–æ—à–µ–ª–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (!connected || !network || !paymentAddress) {
      console.log('‚è≥ Wallet not fully initialized yet:', { connected, network, hasPaymentAddress: !!paymentAddress });
      return
    }
    
    const addressToUse = paymentAddress;

    setLoading(true)
    setError(null)

    try {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º API –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–µ—Ç–∏ –∫–æ—à–µ–ª—å–∫–∞
      const networkName = network || 'mainnet';
      const apiUrl = networkName === 'signet' 
        ? 'https://signet.sandshrew.io/v2/lasereyes'
        : 'https://mainnet.sandshrew.io/v2/lasereyes';
      
      console.log('üåê Using API URL:', apiUrl);
      console.log('üí∞ Checking BTC balance for address:', addressToUse);
      
      const response = await fetch(apiUrl, {
        method: 'POST',
        mode: 'cors',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: JSON.stringify({
          method: 'esplora_address',
          params: [addressToUse],
          jsonrpc: '2.0',
          id: Date.now(),
        }),
      })
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      
      const data = await response.json()
      // console.log('üìä BTC balance response:', data);
      
      if (data.error) {
        throw new Error(data.error.message)
      }
      
      // –í—ã—á–∏—Å–ª—è–µ–º –±–∞–ª–∞–Ω—Å –∏–∑ UTXO –¥–∞–Ω–Ω—ã—Ö
      const result = data.result
      const confirmedBalance = result && result.chain_stats ? 
        (result.chain_stats.funded_txo_sum - result.chain_stats.spent_txo_sum) : 0
      const unconfirmedBalance = result && result.mempool_stats ? 
        (result.mempool_stats.funded_txo_sum - result.mempool_stats.spent_txo_sum) : 0
      
      // console.log('üí∞ Calculated balances:', {
      //   confirmedBalance,
      //   unconfirmedBalance,
      //   total: confirmedBalance + unconfirmedBalance,
      //   address: addressToUse
      // });
      
      setBalance({
        confirmed: confirmedBalance,
        unconfirmed: unconfirmedBalance
      })
    } catch (err) {
      console.error('Error fetching wallet balance:', err)
      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ–Ω—è—Ç–Ω—É—é –æ—à–∏–±–∫—É
      if (err.message.includes('CORS') || err.message.includes('Failed to fetch')) {
        setError('Network error - CORS blocked. Try using a different network or check your connection.')
      } else {
        setError(err.message)
      }
    } finally {
      setLoading(false)
    }
  }, [connected, paymentAddress, network])

  useEffect(() => {
    // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–æ—à–µ–ª–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (connected && network && paymentAddress) {
      const timer = setTimeout(() => {
        fetchBalance()
      }, 500)
      
      return () => clearTimeout(timer)
    }
  }, [paymentAddress, connected, network, fetchBalance])

  return {
    balance,
    loading,
    error,
    refetch: fetchBalance
  }
}

export function useWalletTokens() {
  const { address, connected, network } = useLaserEyes()
  const [tokens, setTokens] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const [hasArbuz, setHasArbuz] = useState(false)

  const fetchTokens = useCallback(async () => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–æ—à–µ–ª–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (!connected || !network || !address) {
      console.log('‚è≥ Wallet not fully initialized yet:', { connected, network, hasAddress: !!address });
      setTokens([])
      setHasArbuz(false)
      return
    }

    setLoading(true)
    setError(null)

    try {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º API –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–µ—Ç–∏ –∫–æ—à–µ–ª—å–∫–∞
      const networkName = network || 'mainnet';
      const apiUrl = networkName === 'signet' 
        ? 'https://signet.sandshrew.io/v2/lasereyes'
        : 'https://mainnet.sandshrew.io/v2/lasereyes';
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          method: 'alkanes_protorunesbyaddress',
          params: [{ address, protocolTag: '1' }],
          jsonrpc: '2.0',
          id: Date.now(),
        }),
      })
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      
      const data = await response.json()
      if (data.error) {
        throw new Error(data.error.message)
      }
      
      // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω—ã –∏–∑ outpoints
      const allTokens = data.result?.outpoints || []
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ ARBUZ —Ä—É–Ω—ã (block: 2, tx: 879 –∏–ª–∏ 25349)
      const arbuzToken = allTokens.find(token => {
        if (token.runes && Array.isArray(token.runes)) {
          return token.runes.some(rune => 
            rune.rune && 
            rune.rune.name === 'ARBUZ' &&
            rune.rune.id && 
            rune.rune.id.block === '0x2' && 
            (rune.rune.id.tx === '0x36f' || rune.rune.id.tx === '0x6305') // 879 –∏–ª–∏ 25349
          )
        }
        return false
      })
      setHasArbuz(!!arbuzToken)
      
      // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ ARBUZ —Ç–æ–∫–µ–Ω—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ ID 2:879 –∏ 2:25349)
      const arbuzTokens = allTokens.filter(token => {
        if (token.runes && Array.isArray(token.runes)) {
          return token.runes.some(rune => 
            rune.rune && 
            rune.rune.name === 'ARBUZ' &&
            rune.rune.id && 
            rune.rune.id.block === '0x2' && 
            (rune.rune.id.tx === '0x36f' || rune.rune.id.tx === '0x6305') // 879 –∏–ª–∏ 25349
          )
        }
        return false
      })
      
      setTokens(arbuzTokens)
    } catch (err) {
      console.error('Error fetching wallet tokens:', err)
      // –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º –∏—Ö
      setError(null)
    } finally {
      setLoading(false)
    }
  }, [connected, address, network])

  useEffect(() => {
    // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–æ—à–µ–ª–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (connected && network && address) {
      const timer = setTimeout(() => {
        fetchTokens()
      }, 600)
      
      return () => clearTimeout(timer)
    }
  }, [address, connected, network, fetchTokens])

  return {
    tokens,
    loading,
    error,
    hasArbuz,
    refetch: fetchTokens
  }
} 

export function useAllTokens() {
  const { address, connected, network } = useLaserEyes()
  const [tokens, setTokens] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  const fetchAllTokens = useCallback(async () => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–æ—à–µ–ª–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (!connected || !network || !address) {
      console.log('‚è≥ Wallet not fully initialized yet:', { connected, network, hasAddress: !!address });
      setTokens([])
      return
    }

    setLoading(true)
    setError(null)

    try {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º API –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–µ—Ç–∏ –∫–æ—à–µ–ª—å–∫–∞
      const networkName = network || 'mainnet';
      const apiUrl = networkName === 'signet' 
        ? 'https://signet.sandshrew.io/v2/lasereyes'
        : 'https://mainnet.sandshrew.io/v2/lasereyes';
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          method: 'alkanes_protorunesbyaddress',
          params: [{ address, protocolTag: '1' }],
          jsonrpc: '2.0',
          id: Date.now(),
        }),
      })
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      
      const data = await response.json()
      if (data.error) {
        throw new Error(data.error.message)
      }
      
      // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω—ã –∏–∑ outpoints
      const allTokens = data.result?.outpoints || []
      
      // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–æ–∫–µ–Ω—ã —Å —Ä—É–Ω–∞–º–∏ (–∞–ª–∫–∞–Ω—ã)
      const alkaneTokens = allTokens.filter(token => 
        token.runes && Array.isArray(token.runes) && token.runes.length > 0
      )
      
      setTokens(alkaneTokens)
    } catch (err) {
      console.error('Error fetching all tokens:', err)
      // –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º –∏—Ö
      setError(null)
    } finally {
      setLoading(false)
    }
  }, [connected, address, network])

  useEffect(() => {
    // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–æ—à–µ–ª–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (connected && network && address) {
      const timer = setTimeout(() => {
        fetchAllTokens()
      }, 700)
      
      return () => clearTimeout(timer)
    }
  }, [address, connected, network, fetchAllTokens])

  return {
    tokens,
    loading,
    error,
    refetch: fetchAllTokens
  }
} 